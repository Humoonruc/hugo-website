---
title: "Input-Output"
author: "Humoon"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: show
    df_print: paged
    fig_caption: yes
    theme: united
    highlight: haddock
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: true
      smooth_scroll: FALSE
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width = 6, fig.height = 4.5, 
                      fig.path = 'Figs/', warning = FALSE, 
                      message = FALSE, cache = T, 
                      cache.comments = F, comment = '')
```

```{r setup}
# load necessary packages
library('pacman')
p_load(tidyverse,readxl,xlsx,lubridate,RODBC)
```

# 相对路径

`./`代表本级路径，`../`代表上一级路径

# Input

## Input from keyboard

### c()函数

直接输入一个向量

```{r}
x <- c(1,2,3,4); x
y <- c("a","b","c"); y
```

### scan()函数

每输入一个分量后按**回车或空格**输入下一个分量。输入完数据，按两次回车键，则数据录入完毕。
```{r, eval=FALSE}
x <- scan()
```

## Input from R packages

* 查看当前环境下的数据ls()
* 删除数据rm()
* 查看所有预先提供的数据data()
* 查看某个包所有预先提供的数据data(package=" ")
* 读入某个包的数据data(dataname, package=" ")

```{r}
library(SemiPar)
data(package = "SemiPar")
data(copper,package = "SemiPar")
head(copper)
```

## Input from txt

> readr::read_table(file, col_names = TRUE, col_types = NULL,
  locale = default_locale(), na = "NA", skip = 0, n_max = Inf,
  guess_max = min(n_max, 1000), progress = show_progress(),
  comment = "", skip_empty_rows = TRUE)

## Input excel files

### readr::read_csv()

> read_csv(file, col_names = TRUE, col_types = NULL,locale = default_locale(), na = c("", "NA"), quoted_na = TRUE,quote = "\"", comment = "", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = show_progress(), skip_empty_rows = TRUE)

* readr包的read_csv()将文件中的数据读为tibble    
* 当运行read_csv()且不指定列的数据类型时，它会打印一份数据列说明，给出每个列的名称和它自动解析的列的类型。这是readr包的一项重要功能。但强烈建议编程者提供col_types参数，这样可以确保数据导入脚本的一致性，并可以重复使用
* col_names = T, 使用首行作为列名称；col_names = F, 当数据首行不是列名称时，函数自动将列标记为X1,X2,...；col_names = 字符串向量，直接赋列名称
* skip = n, 忽略前n行（通常为MetaData）
* comment = '#' 忽略所有以'#'开头的行
* na = 设定缺失值，默认空白格和'NA'都是缺失值

### xlsx::read.xlsx()

注意：xlsx包的read.xlsx()读取文件生成数据框时，可能会将字符向量转化为因子！！！

```{r readdata}
aa <- read.xlsx("出口额累计.xls", sheetIndex = 1, startRow = 3, 
                header = F, encoding = "UTF-8") %>% 
  rename(date = X1, ex_acc = X2)
class(aa$date) # 发现data居然是一个因子变量！
aa

# 所以，一定要加入参数 stringsAsFactors = FALSE
aa <- read.xlsx("出口额累计.xls", sheetIndex = 1, startRow = 3, 
                header = F, encoding = "UTF-8", 
                stringsAsFactors = F) %>% 
  rename(date = X1, ex_acc = X2) %>% 
  filter(!is.na(date), !is.na(ex_acc)) 
class(aa$date)

# 将excel内置的日期格式先转化为整数，再转化为R的日期格式
aa$date <- aa$date %>% 
  as.integer() %>% 
  as.Date(origin = '1899-12-30')
aa
```


### readxl::read_excel()

> read_excel(path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = "", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = "unique")

readxl包的read_excel()读入数据生成的是tibble()，所以不加 stringsAsFactors = F 也不会将字符向量转换为因子

```{r}
bb <- read_excel("出口额累计.xls", sheet = 1,col_names = 
                   c('date','ex_acc'), skip = 2) %>% 
  filter(!is.na(date), !is.na(ex_acc)) 
bb

# 转换时间格式
bb$date <- bb$date %>% 
  as.integer() %>% 
  as.Date(origin = '1899-12-30')
bb

# 在read_excel()中可以加入col_types参数直接读取各种格式的日期
bb <- read_excel("出口额累计.xls", sheet = 1, skip = 2,
                 col_names = c('date','ex_acc'),
                 col_types = c('date','numeric')) %>% 
  filter(!is.na(date), !is.na(ex_acc)) 
bb
```

### 结论：使用 *readxl::read_excel()* 读取xls和xlsx文件

其优点有：  

* 生成tibble()，不存在字符向量转化为因子的烦恼   
* 可以在读取时用col_names参数直接对列进行命名   
* col_types参数可以直接转换日期值，非常方便     
* 有skip参数可以跳过许多数据表中前几行的Metadata    
* 可以快速读取excel的大量数据，不易出现内存溢出错误        


## tibble的性质

>
* tibble用美元符号引用变量名直接就是一个向量，而不像dataframe是一个list    
* 用print()打印tibble只显示10行，避免输出太长。print(n = 10, width = Inf)可以自定义打印的长度和宽度。   
* 也可以用options(tibble.print_max=n,tibble.print_min=m)进行全局性设置：如果多于m行，则只打印出n行。
* 对于大数据，也可以用 %>% View()或 %T>% View()查看
* 提取列可以用管道操作：tibble %>% .$x 和 tibble %>% .[["x"]]


## Input from Access

两个必要条件：

* 32位的R
* mdb格式的数据库文件（即另存为Access02-03格式）

总之，R对于Access的支持不太好，也不够新。


# Output

## Output to txt

## Output excel files

### readr::write_csv()

> write_csv(x, path, na = "NA", append = FALSE, col_names = !append,quote_escape = "double")

这个函数输出的文件能够顺利读取的概率更高，因为：  

* 它们总是使用UTF-8 对字符串进行编码   
* 它们使用ISO 8601格式来保存日期和日期时间数据，以便这些数据不论在何种环境下都更容易解析

**注意，当保存为CSV文件时，列的数据类型信息就丢失了：这使得CSV文件在暂存临时结果时有些不可靠——每次加载时都要重建列类型。**

### 结论：使用 *xlsx::write.xlsx()*

- 优点：可以使用sheetName和append参数将多个数据框写入一个数据簿的不同数据表中，便于查看  
- 缺点：不支持对tibble的写入，解决办法为  
  - 用as.data.frame()将tibble转化为dataframe，再用xlsx::write.xlsx()写入一个数据簿的不同数据表中  
  - as.data.frame()不会改变变量的类型，字符型仍是字符型，因子型仍是因子型  


# readr包自动转化数据类型的原理

readr将数据都当成字符串，自动猜出文件每列的数据类型，解析各列为相应的数据类型。

解析向量依靠函数族parse_*()。这些函数接受一个字符向量，并返回一个特定向量，如逻辑、整数或日期向量。具体来说，重要的解析函数有 8 种。

* parse_logical()和parse_integer()分别解析逻辑值和整数。这两个解析函数基本不会出现问题   
* parse_double()是严格的数值型解析函数，parse_number()则是灵活的数值型解析函数。这两个函数要比你预想的更复杂，因为世界各地书写数值的方式不尽相同  
* parse_character()似乎太过简单，甚至没必要存在。但一个棘手的问题使得这个函数变得非常重要：字符编码   
* parse_factor()函数可以创建因子，R使用这种数据结构来表示分类变量   
* parse_datetime()、parse_date()和parse_time()函数可以解析不同类型的日期和时间。它们是最复杂的，因为有太多不同的日期书写形式

## 解析数值

1. parse_double()的locale(decimal_mark=)参数可以覆盖默认的小数点。
```{r}
a <- parse_double("3121,23", locale = locale(decimal_mark = ","));a
```


2. parse_number()可以忽略数值前后的非数值型字符。这个函数特别适合处理货币和百分比，也可以提取嵌在文本中的数值。
```{r}
parse_number("It cost $123.45.")
parse_number("I want 45% of it.")

```

3. parse_number()和locale(grouping_mark=)参数可以忽略位数间隔符(grouping mark)
```{r}
parse_number("123.456.789", 
             locale = locale(grouping_mark = "."))
```

## 解析字符串

非英文字符的编码方式有许多种，对其解码需要用locale(encoding=)参数设置编码方式，
```{r}
x2 <- "\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"
parse_character(x2, locale = locale(encoding = "Shift-JIS"))
```

## 解析因子
```{r}
fruit <- c("apple", "banana")
parse_factor(c("apple", "banana", "bananana"), levels = fruit)
```

## 解析日期与时间

R中的日期从1970-01-01开始计算，而Excel从1899-12-30开始计算

* parse_datetime() 期待的是符合 ISO 8601 标准的日期时间。 ISO 8601 是一种国际标准，其中日期的各个部分按从大到小的顺序排列，即年、月、日、小时、分钟、秒  
```{r}
parse_datetime("2010-10-01T2010")
# 如果时间被省略了，那么它就会被设置为午夜0点0分
parse_datetime("20101010")
```

* parse_date() 期待的是四位数的年份、一个 - 或 / 月、一个 - 或 / 日
```{r}
parse_date("2010-10-01")
```

* parse_time() 期待的是小时、 :、分钟、可选的 : 和秒，以及一个可选的 a.m./p.m. 标识符
```{r}
library(hms)
parse_time("01:10 am")
parse_time("20:10:01")
```

* 自己设定时间格式

符号|含义    
----|----
%Y|4位数年份
%y|2位数年份(00-69 → 2000-2069, 70-99 → 1970-1999)
%m|2位数月份
%b|简写月份
%B|月份全称
%d|日期，一位数或两位数
%e|两位数日期
%H|0-23小时
%I%p|0-12小时，%p表示am/pm
%M|分钟
%S|整数秒
%OS|实数秒
%Z|时区
%z|与国际标准时间的时差
%.|忽略一个非数值字符
%*|忽略所有非数值字符

注意，若对非英语月份名称使用 %b 或 %B，需要在locale()函数中设置语言参数。
```{r}
parse_date("1 janvier 2015", "%d %B %Y", 
           locale = locale("fr"))
```

