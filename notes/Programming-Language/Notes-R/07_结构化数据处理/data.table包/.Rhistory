?setDF()
?setDF()
## global options
knitr::opts_chunk$set(
fig.width = 6, fig.asp = 0.618,
out.width = "80%", fig.align = "center",
fig.path = 'Figures/', fig.show = "hold",
warn = 1, warning = FALSE, message = FALSE, echo = TRUE,
comment = '', collapse = F,
cache = T, cache.comments = F, autodep = TRUE
)
## use necessary packages
library('pacman')
p_load(tidyverse, lubridate, data.table, # 数据整理
ggthemes, showtext, gridExtra, # 可视化
lmtest, plm, orcutt, stats, forecast, zoo, # 统计分析
rvest, httr, xml2, # 爬虫
sqldf, DT, # I/O
jiebaR, wordcloud2, webshot, htmlwidgets # 文本分析
)
options(sqldf.driver = "SQLite")
dt = data.table(a = c('A','B','C','A','A','B'), b = 1:6)
?setDF()
?setDT()
df <- data.frame(a = c('A','B','C','A','A','B'), b = 1:6)
dt2 <- setDT(df)
# dt2 <- as.data.table(df)
class(dt2)
channel <- dbConnect(
SQLite(),
dbname = "C:/Users/humoo/OneDrive/ICT/DataBase/trade.db")
total = dbReadTable(channel,"total") %>% select(-time) %>% setDT()
class(total)
dbDisconnect(channel)
iris <- fread("iris.csv")
class(iris)
View(dt)
dt[, c := b + 2]
dt
dt
dt[, d1 := 1:6, d2 := 2:7]
View(dt)
dt[, .(d1,d2) := list(1:6, 2:7)]
dt[, .(d1, d2) := list(1:6, 2:7)]
dt[, list(d1, d2) := list(1:6, 2:7)]
View(dt)
dt = data.table(a = c('A','B','C','A','A','B'), b = 1:6)
dt[, 'c' := b + 2] # (b + 2) AS c
View(dt)
dt = data.table(a = c('A','B','C','A','A','B'), b = 1:6)
View(dt)
dt[, 'c' := 'b' + 2] # (b + 2) AS c
View(dt)
dt[, c(d1,d2) := list(1:6, 2:7)]
View(dt)
dt[, 'c' := b + 2] # (b + 2) AS c
dt
dt
View(dt)
# 增加2列，列名为c1, c2，第1种写法
dt[,`:=`('c1' = 1:6, 'c2' = 2:7)]
View(dt)
# 增加2列，第2种写法
dt[, c('d1','d2') := list(1:6, 2:7)]
View(dt)
# 删除c1列
dt[, 'c1' := NULL]
View(dt)
# 同时删除d1,d2列
dt[, c('d1','d2') := NULL]
View(dt)
# 给b赋值为30
dt[, 'b' := 30]
View(dt)
# 对a列值为B、c2列值大于3的行，其b列赋值为100
dt[a == 'B' & c2 > 3, 'b' := 100]
View(dt)
# 对a列值为B、c2列值大于3的行，其b列赋值为100
dt[a == 'B' & c2 > 3, 'b' := 100]
# 对a列值为B、c2列值大于3的行，其b列赋值为100
dt['a' == 'B' & c2 > 3, 'b' := 100]
View(dt)
dt = data.table(a = c('A','B','C','A','A','B'), b = 1:6)
View(dt)
dt[, c := b + 2] # (b + 2) AS c
View(dt)
# 增加2列，列名为c1, c2，第1种写法
dt[,`:=`(c1 = 1:6, c2 = 2:7)]
View(dt)
# 增加2列，第2种写法
dt[, c(d1,d2) := list(1:6, 2:7)]
dt = data.table(a = c('A','B','C','A','A','B'), b = 1:6)
dt[, c := b + 2] # (b + 2) AS c
dt
# 增加2列，列名为c1, c2，第1种写法
dt[,`:=`(c1 = 1:6, c2 = 2:7)]
dt
# 增加2列，第2种写法
dt[, c('d1', 'd2') := list(1:6, 2:7)]
dt
# 删除c1列
dt[, c1 := NULL]
dt
# 同时删除d1,d2列
dt[, c(d1,d2) := NULL]
# 同时删除d1,d2列
dt[, c('d1','d2') := NULL]
dt
View(dt)
# 给b赋值为30
dt[, b := 30]
dt
# 对a列值为B、c2列值大于3的行，其b列赋值为100
dt[a == 'B' & c2 > 3, b := 100]
dt
View(dt)
# 另一种写法
dt[, b := ifelse(a == 'B' & c2 > 3, 50, b)]
dt
dt3 <- setDT(df, key = 'b') # 这个函数将对象原地转换，不必复制
df3 <- setDF(dt3)
setnames(total, 'trade', 'total') # 将trade列名设为total
total[, id := .I] # .I意为1:.N，这句为total加了一列序号
setcolorder(total, id) # 列的重排序，如果只写出了一部分列，
setcolorder(total, 'id') # 列的重排序，如果只写出了一部分列，
df
class(df)
View(dt)
View(dt)
dt[, list(d1, d2) := list(1:6, 2:7)]
# 对整个b列数据求和
dt[, sum(b)]
# 按a列分组，并对b列按分组求和，运算结果用
dt[, sum(b), by = a]
dt[, sum(b), by = a]
# 在查询中除了提取旧变量，也创建新变量
total[, list(year, month, export, import, ratio = export / import)]
total[, .(year, month, export, import, ratio = export / import)]
# 排序
total[order(month, decreasing = T)]
total[, .N, by = year]
total[, .N, by = year]
# 排序
total[order(month, decreasing = T)]
total[, .N, by = year] # 先分组，再显示组的行数
total[, .N, by = .(year, month)] # year 和 month 是有先后顺序的
total[, .(avg_ex = mean(export)), by = .(year)]
View(total)
total[, .(avg_ex = mean(export)), by = .(year)]
total[, avg_ex = mean(export), by = .(year)]
total[, avg_ex := mean(export), by = .(year)]
View(total)
total[, avg_ex = mean(export), by = .(year)]
total[, list(avg_ex = mean(export)), by = .(year)]
total[, list(avg_ex = mean(export)), by = .(year)]
total[, avg_ex = mean(export), by = .(year)]
total[, (avg_ex = mean(export)), by = .(year)]
View(total)
View(dt)
View(total)
blogdown:::preview_site()
## global options
knitr::opts_chunk$set(
fig.width = 6, fig.asp = 0.618,
out.width = "80%", fig.align = "center",
fig.path = 'Figures/', fig.show = "hold",
warn = 1, warning = FALSE, message = FALSE, echo = TRUE,
comment = '', collapse = F,
cache = T, cache.comments = F, autodep = TRUE
)
## use necessary packages
library('pacman')
p_load(tidyverse, lubridate, data.table, # 数据整理
ggthemes, showtext, gridExtra, # 可视化
lmtest, plm, orcutt, stats, forecast, zoo, # 统计分析
rvest, httr, xml2, # 爬虫
sqldf, DT, # I/O
jiebaR, wordcloud2, webshot, htmlwidgets # 文本分析
)
options(sqldf.driver = "SQLite")
df <- data.frame(a = c('A','B','C','A','A','B'), b = 1:6)
dt2 <- setDT(df)
class(dt2)
dt2
dt3 <- dt2 %>% mutate(c = b)
dt3
class(dt3)
blogdown:::preview_site()
blogdown:::preview_site()
blogdown:::preview_site()
blogdown:::preview_site()
blogdown:::preview_site()
dt <- data.frame(a = 1:6,
b = c('A','B','C','A','A','B'))
dt[1:2, ]; dt
dt[1:2, ]
dt
dt <- data.frame(a = 1:6,
b = c('A','B','C','A','A','B'))
dt
dt[1:2, ]
dt
dt
dt[1:2, ]
blogdown:::preview_site()
blogdown:::preview_site()
dt[, .SD[1], by = a]
# 对整个b列数据求和
dt[, sum(b)]
## global options
knitr::opts_chunk$set(
fig.width = 6, fig.asp = 0.618,
out.width = "80%", fig.align = "center",
fig.path = 'Figures/', fig.show = "hold",
warn = 1, warning = FALSE, message = FALSE, echo = TRUE,
comment = '', collapse = F,
cache = T, cache.comments = F, autodep = TRUE
)
## use necessary packages
library('pacman')
p_load(tidyverse, lubridate, data.table, # 数据整理
ggthemes, showtext, gridExtra, # 可视化
lmtest, plm, orcutt, stats, forecast, zoo, # 统计分析
rvest, httr, xml2, # 爬虫
sqldf, DT, # I/O
jiebaR, wordcloud2, webshot, htmlwidgets # 文本分析
)
options(sqldf.driver = "SQLite")
dt = data.table(a = c('A','B','C','A','A','B'),
b = 1:6)
class(dt)
df <- data.frame(a = c('A','B','C','A','A','B'),
b = 1:6)
dt2 <- setDT(df)
class(dt2)
channel <- dbConnect(
SQLite(),
dbname = "C:/Users/humoo/OneDrive/ICT/DataBase/trade.db")
blogdown:::preview_site()
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
View(market_data)
set.seed(123)
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(123)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
head(market_data)
plot(price ~ date, data = market_data,
type = "l",
main = "Market data")
market_data[, range(date)]
monthly <- market_data[,
.(open = price[[1]], high = max(price),
low = min(price), close = price[[.N]]), # 每组统计最大、最小、最早、最晚价格
keyby = .(year = year(date), month = month(date))] #按月分组
head(monthly)
head(monthly)
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(123)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
plot(price ~ date, data = market_data,
type = "l",
main = "Market data")
market_data[, range(date)] #没有:=，所以这不是update，而是summarize
monthly <- market_data[,
.(open = price[[1]], high = max(price),
low = min(price), close = price[[.N]]), # 每组统计最大、最小、最早、最晚价格，这就是K线图！！！
keyby = .(year = year(date), month = month(date))] #按月分组
head(monthly)
# 中间的运算部分还可以是画图
oldpar <- par(mfrow = c(1, 2))
market_data[, {
plot(price ~ date, type = "l",
main = sprintf("Market data (%d)", year))
}, by = .(year = year(date))]
par(oldpar)
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(123)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
plot(price ~ date, data = market_data,
type = "l",
main = "Market data")
market_data[, range(date)] #没有:=，所以这不是update，而是summarize
monthly <- market_data[,
.(open = price[[1]], high = max(price),
low = min(price), close = price[[.N]]), # 每组统计最大、最小、最早、最晚价格，这就是K线图！！！
keyby = .(year = year(date), month = month(date))] #按月分组
head(monthly)
# 中间的运算部分还可以是画图
oldpar <- par(mfrow = c(1, 2))
market_data[, {
plot(price ~ date, type = "l",
main = sprintf("Market data (%d)", year))
}, by = .(year = year(date))]
par(oldpar)
data("diamonds", package = "ggplot2")
setDT(diamonds)
diamonds[, {
m <- lm(log(price) ~ carat + depth)
as.list(coef(m))
}, keyby = .(cut)]
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(123)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(123)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
## global options
knitr::opts_chunk$set(
fig.width = 6, fig.asp = 0.618,
out.width = "80%", fig.align = "center",
fig.path = 'Figures/', fig.show = "hold",
warn = 1, warning = FALSE, message = FALSE, echo = TRUE,
comment = '', collapse = F,
cache = T, cache.comments = F, autodep = TRUE
)
## use necessary packages
library('pacman')
p_load(tidyverse, lubridate, data.table, # 数据整理
ggthemes, showtext, gridExtra, # 可视化
lmtest, plm, orcutt, stats, forecast, zoo, # 统计分析
rvest, httr, xml2, # 爬虫
sqldf, DT, # I/O
jiebaR, wordcloud2, webshot, htmlwidgets # 文本分析
)
options(sqldf.driver = "SQLite")
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(123)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
plot(price ~ date, data = market_data,
type = "l",
main = "Market data")
market_data[, range(date)] #没有:=，所以这不是update，而是summarize
monthly <- market_data[,
.(open = price[[1]], high = max(price),
low = min(price), close = price[[.N]]), # 每组统计最大、最小、最早、最晚价格，这就是K线图！！！
keyby = .(year = year(date), month = month(date))] #按月分组
head(monthly)
monthly <- market_data[,
.(open = price[[1]], high = max(price),
low = min(price), close = price[[.N]]), # 每组统计最大、最小、最早、最晚价格，这就是K线图！！！
keyby = .(year = year(date), month = month(date))] #按月分组
head(monthly)
```{r, eval=TRUE}
# 把 j 当成一个大的匿名函数了
oldpar <- par(mfrow = c(1, 2))
market_data[, {
plot(price ~ date, type = "l",
main = sprintf("Market data (%d)", year))
}, by = .(year = year(date))] # 按年分组，画两幅图
par(oldpar)
data("diamonds", package = "ggplot2")
setDT(diamonds)
diamonds[, {
m <- lm(log(price) ~ carat + depth)
as.list(coef(m))
}, keyby = .(cut)]
# .SD 指代分组后的所有子集，从而.SD[[column]]就是一个向量，可以被传递给 mean()
average <- function(column) {
market_data[, .(average = mean(.SD[[column]])),
by = .(year = year(date))]
}
average('price')
average('volume')
price_cols <- paste0("price", 1:3)
market_data[, (price_cols) :=
lapply(1:3, function(i) round(price + rnorm(.N, 0, 5), 2))]
head(market_data)
cols <- colnames(market_data)
price_cols <- cols[grep("^price", cols)] # 所有以price开头的列
price_cols
market_data[, (price_cols) := lapply(.SD, zoo::na.locf),
.SDcols = price_cols]
head(market_data)
unlink('data.table数据类型_cache', recursive = TRUE)
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(125)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
rm(list = ls())
## global options
knitr::opts_chunk$set(
fig.width = 6, fig.asp = 0.618,
out.width = "80%", fig.align = "center",
fig.path = 'Figures/', fig.show = "hold",
warn = 1, warning = FALSE, message = FALSE, echo = TRUE,
comment = '', collapse = F,
cache = T, cache.comments = F, autodep = TRUE
)
## use necessary packages
library('pacman')
p_load(tidyverse, lubridate, data.table, # 数据整理
ggthemes, showtext, gridExtra, # 可视化
lmtest, plm, orcutt, stats, forecast, zoo, # 统计分析
rvest, httr, xml2, # 爬虫
sqldf, DT, # I/O
jiebaR, wordcloud2, webshot, htmlwidgets # 文本分析
)
options(sqldf.driver = "SQLite")
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(125)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(125)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(125)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
unlink('data.table数据类型_cache', recursive = TRUE)
## global options
knitr::opts_chunk$set(
fig.width = 6, fig.asp = 0.618,
out.width = "80%", fig.align = "center",
fig.path = 'Figures/', fig.show = "hold",
warn = 1, warning = FALSE, message = FALSE, echo = TRUE,
comment = '', collapse = F,
cache = T, cache.comments = F, autodep = TRUE
)
## use necessary packages
library('pacman')
p_load(tidyverse, lubridate, data.table, # 数据整理
ggthemes, showtext, gridExtra, # 可视化
lmtest, plm, orcutt, stats, forecast, zoo, # 统计分析
rvest, httr, xml2, # 爬虫
sqldf, DT, # I/O
jiebaR, wordcloud2, webshot, htmlwidgets # 文本分析
)
# options(sqldf.driver = "SQLite")
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(125)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
## global options
knitr::opts_chunk$set(
fig.width = 6, fig.asp = 0.618,
out.width = "80%", fig.align = "center",
fig.path = 'Figures/', fig.show = "hold",
warn = 1, warning = FALSE, message = FALSE, echo = TRUE,
comment = '', collapse = F,
cache = T, cache.comments = F, autodep = TRUE
)
## use necessary packages
library('pacman')
p_load(tidyverse, lubridate, data.table, # 数据整理
ggthemes, showtext, gridExtra, # 可视化
lmtest, plm, orcutt, stats, forecast, zoo, # 统计分析
rvest, httr, xml2, # 爬虫
sqldf, DT, # I/O
jiebaR, wordcloud2, webshot, htmlwidgets # 文本分析
)
# options(sqldf.driver = "SQLite")
market_data <- data.table(date = as.Date("2015-05-01") + 0:299)
set.seed(125)
# price是一个随机游走过程，volume是随机数
market_data[, `:=`(
price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
volume = rbinom(300, 5000, 0.8)
)]
head(market_data)
