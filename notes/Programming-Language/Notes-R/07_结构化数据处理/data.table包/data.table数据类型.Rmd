---
title: "data.table 数据类型"
subtitle: ''
author: "Humoon"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    fig_caption: yes
    theme: united
    highlight: haddock
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: true
      smooth_scroll: FALSE
  rticles::ctex:
    df_print: default
    fig_caption: yes
    number_sections: false
  word_document:
    fig_caption: yes
    toc: yes
    toc_depth: 3
    reference_docx: 
  pdf_document:
    toc: yes
    toc_depth: '2'
documentclass: ctexart
classoption: hyperref,
---

```{r setup, include = FALSE}

## global options
knitr::opts_chunk$set(
  fig.width = 6, fig.asp = 0.618,
  out.width = "80%", fig.align = "center",
  fig.path = 'Figures/', fig.show = "hold",
  warn = 1, warning = FALSE, message = FALSE, echo = TRUE, 
  comment = '', collapse = F, 
  cache = T, cache.comments = F, autodep = TRUE
  )

## use necessary packages
library('pacman')
p_load(tidyverse, lubridate, data.table, # 数据整理
       ggthemes, showtext, gridExtra, # 可视化
       lmtest, plm, orcutt, stats, forecast, zoo, # 统计分析  
       rvest, httr, xml2, # 爬虫
       sqldf, DT, # I/O
       jiebaR, wordcloud2, webshot, htmlwidgets # 文本分析
       )
# options(sqldf.driver = "SQLite") 
```

> data.table 对象兼容 dplyr 系列函数，被其操作后，返回值仍为 data.table. 故今后凡是操作数据框都可以默认使用 data.table 格式。

> 当需要保留原始数据时，使用 dplyr 系列函数，不改变原始数据；但不需要保留时，可以使用 data.table 的象牙操作符，追求速度和简洁。

# 创建

## 直接创建data.table

```{r}
dt = data.table(a = c('A','B','C','A','A','B'), 
                b = 1:6)
class(dt)
```

## 将 data.frame 转化为 data.table

> as.data.table() 和 setDT()

```{r}
df <- data.frame(a = c('A','B','C','A','A','B'), 
                 b = 1:6)
dt2 <- setDT(df)
class(dt2)

channel <- dbConnect(
  SQLite(),
  dbname = "C:/Users/Humoonruc/OneDrive/ICT/DataBase/trade.db")
total = dbReadTable(channel,"total") %>% select(-time) %>% setDT()
class(total)
dbDisconnect(channel)
```

`set*()`函数族，不复制数据，节省时间

```{r}
dt3 <- setDT(df, key = 'b')
df3 <- setDF(dt3)

setnames(total, 'trade', 'total') # 将列名trade改为total
head(total)
total[, id := .I] # .I意为1:.N，这句为total加了一个序号索引列
setcolorder(total, 'id') 
# 列的重排序，默认第二个参数是一个列名向量。如果只写出了一部分列，则其他列按照原来的顺序
head(total)
```

## data.table I/O

fread() 可以将能直接将.csv .txt 等格式的文件读为 data.table 格式，fwrite() 可以写 data.table 数据。在处理大数据时，它们的速度非常快。

建议读写文件统一使用这两个函数

```{r}
iris <- fread("iris.csv")
class(iris)
```

# data.table 查询语法

## 统一范式

> `dt[i, j, by, ...]`，很像 SQL 语句，用 i 选择行（就像 WHERE 子句），用 by 或 keyby[^1] 分组（就像 GROUP BY 子句），提取[^2] 或计算 j （就像 SELECT 子句）。

[^1]: 能自动将分组变量设为key.

[^2]: 要用list()或.()

## 特殊符号

| 特殊符号 | 说明                                                          |
|----------|---------------------------------------------------------------|
| .()      | 代替list()                                                    |
| .N       | 总行数                                                        |
| .SD      | 行方向，每个分组对应的原始数据框的subset，除 by 或 keyby 的列 |
| .SDcols  | 与.SD连用，用来选择哪些列包含在.SD中                          |
| .BY      | 包含所有by分组变量的list                                      |
| .I       | 整数向量seq_len(nrow(x))                                      |
| .GRP     | 分组索引                                                      |
| .NGRP    | 分组数                                                        |
| .EACHI   | 用于by/keyby = .EACHI，表示根据i表达式的每一行分组            |

## 链式操作

> DT[...][...][...]

或写为：

    DT[
      ...
    ][
      ...
    ][
      ...
    ]

## Subset rows using i

选择行可以接受的运算符除了常用的逻辑运算符，还包括 `%like%` (匹配模式，有点像正则表达式) 和 `%between%`

data.table[] 方括号中只有一个参数时，默认为 i 参数，表示对行操作。

```{r}
dt3 <- data.table(a = 1:6, b = c('A','B','C','A','A','B'))
dt3[1:2, ]
dt3[a > 5,]

# 选出最后一行
iris[.N]

# 选出第8行
iris[8]

# 选出第一行和最后一行
iris[c(1, .N)]

# 选出满足特定条件的行
iris[Species == 'virginica']
```

## Manipulate columns with j

-   原地赋值时，可以用字符串向量c('列名')指代列
-   非原地赋值时，只能用list(列名)或.(列名)，而不能用c('列名')

### 象牙操作符 `:=`[^3]

[^3]: 原地修改的性能更高，避免了对数据的复制。

在原数据框上操作。这个操作符有点像 SQL 语句中的 `AS` 关键词，但左为列名，右为表达式。**一定注意，这个符号会修改原始数据，因而在单纯的查找中，不要用这个符号！**

-   给data.table对象增加一列，`data.table[, colname := var1]`
-   给data.table对象删除一列，就是给这列赋值为空，`data.table[, colname := NULL]`
-   修改data.table对象的值，通过索引定位后进行值的替换，`data.table[condition, colname := value]`

单个列名不用加引号，多个列名组成的向量，必须加引号并用逗号隔开。

```{r}
dt[, c := b + 2] # (b + 2) AS c
dt

# 增加2列，列名为c1, c2，第1种写法
dt[,`:=`(c1 = 1:6, c2 = 2:7)] # := 很像一个update函数
dt

# 增加2列，第2种写法，两种写法都表示原地赋值
dt[, c('d1', 'd2') := list(1:6, 2:7)]
dt

# 删除c1列
dt[, c1 := NULL]
dt

# 同时删除d1,d2列
dt[, c('d1','d2') := NULL]
dt

# 给b赋值为30
dt[, b := 30]
dt

# 对a列值为B、c2列值大于3的行，其b列赋值为100
dt[a == 'B' & c2 > 3, b := 100]
dt

# 另一种写法
dt[, b := ifelse(a == 'B' & c2 > 3, 50, b)]
dt
```

### 用赋值 `=` 而非象牙操作符

表示不是更新列或新增列，不是在原来的数据框基础上改动。

而是新创建一个数据框。此时，j 中的多个列不能写成向量，而要写成列表，用.()或list()

## Group according to by

by 分组， keyby 不仅分组且立刻定义键

```{r}
# 对整个b列数据求和
dt[, sum(b)]

# 按a列分组，并对b列按分组求和，运算结果的列名自动命名为 V1
dt[, sum(b), by = a]

# 提取每一组的第一行，组成新数据框
dt[, .SD[1], by = a]

# 提取每一组的最后一行，组成新数据框
dt[, .SD[.N], by = a]

# 注意，没用象牙操作符，不改变原始数据，故必须用列表封装列名
# total[, list(year, month, export, import, ratio = export / import)]
total[, .(year, month, export, import, ratio = export / import)]

# 行排序
total[order(month, decreasing = T)]

total[, .N, by = year] # 先分组，再显示每组行数
total[, .N, by = .(year, month)] # year 和 month 是有先后顺序的
total[, .(avg_ex = mean(export)), by = .(year)]
```

# data.table 定义的独立辅助函数

## 行排序

`setorder(dt, a, -b)` 重新排列行，先a按升序，再b按降序

## 行去重

`unique(dt, by = c("a","b"))` 检查by的列，提取不重复的行

`uniqueN(dt, by = c("a","b"))` 检查by的列，计算每个不重复的行出现了多少次

## 列重命名

`setnames(dt, c("a","b"), c("x","y")` 列重命名

## 提前和滞后 lead and lag

```{r}
dt[, c := shift(a, 1)]
dt
dt[, c := shift(a, 1, type = "lead")]
dt
```

这样可以很容易地加入提前或滞后列，进行同比增长率等计算

## 遍历操作各列

lapply()，返回一个列表

```{r}
dt <- data.table(a = c(1, 2, 3), b = c(4, 5, 6))
# 遍历a和b两列，都求平均值
dt[, lapply(.SD, mean), .SDcols = c("a", "b")]
cols <- c("a")
# 只遍历a列，求平均值，赋给新加入的a_m列
dt[, paste0(cols, "_m") := lapply(.SD, mean), .SDcols = cols]
dt 
```

# 连接操作

## 键

> setkey(d1, v1, v3, ...)

将某些列定义为 keys后，就可以通过键选择行，以及进行关系数据连接，比无键时快170倍。同时，可以用 mult 参数对查询结果增加过滤条件，让代码本身也变得更高效。

    # 设置a列为主键
    setkey(dt, a) 
    # setkeyv(dt, 'a') 这个函数仅接受字符串作为第二个参数
    key(dt)

    # 打印dt对象，发现数据已经按照a列字母对应ASCII码值进行了排序。
    dt

    # 取a列中值为B的行，设置主键后可省略`a==`
    dt["B"]

    # 取a列中值为B的行，并保留查询结果的第一行
    dt["B", mult = "first"]

    # 取a列中值为B的行，并保留查询结果的最后一行
    dt["B", mult = "last"]

    # 取a列中值为b的行，没有数据则为NA
    dt["b"]

```{r}
setkey(total, year, month)
total[list(2019, 3)] # 省略了 year == 2019 & month == 3
total[.(2019)] # 省略了 year == 2019
# 不能写total[list(3)]，得不出有意义的结果
```

## Join

> 为了减轻记忆负担，join操作用dplyr包的函数即可

基本语法为`dt1[dt2, on = .(b = y)]`

-   若连个表都定义了 key, 第二个参数不用填

-   若没有定义key，...要写 on = "commonColumn" 或 by.dt1 = "c1", by.dt2 = "c2"

例：学生考试的场景。按照ER设计方法，我们通常会按照实体进行数据划分。这里存在2个实体，一个是学生，一个是成绩。学生实体包括学生姓名等基本资料，而成绩实体包括考试的科目和成绩。通过设置两个主键，对2个数据集进行连接。

```{r}
# 6个学生
student <- data.table(id = 1:6, 
                      name = c('Dan','Mike','Ann','Yang','Li','Kate'))
student

# 分别参加A和B两门考试
score <- data.table(id = 1:12, stuId = rep(1:6,2), 
                    score = runif(12,60,99), 
                    course = c(rep('A',6), rep('B',6)))
score

# 设置student数据集的key为id
setkey(student,"id")

# 设置score数据集的key为stuId
setkey(score,"stuId")

# 连接
student[score, nomatch = NA, mult = "all"]

rm(list = ls())
```

## 集合运算

      fintersect(dt1, dt2)
      fsetdiff(dt1, dt2)
      funion(dt1, dt2)
      fsetequal(dt1, dt2)

# 高级应用实例

```{r}
# 产生300天的序列
market_data <- data.table(date = as.Date("2015-05-01") + 0:299) 
set.seed(125)  

# price是一个随机游走过程，300天的变化率累乘；volume是随机数
market_data[, `:=`(
  price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2),
  volume = rbinom(300, 5000, 0.8)
)]

head(market_data)

plot(price ~ date, data = market_data, 
  type = "l",
  main = "Market data")

market_data[, range(date)] #没有:=，所以这不是update，而是summarize

monthly <- market_data[, 
  .(open = price[[1]], high = max(price), 
    low = min(price), close = price[[.N]]), # 每组统计最大、最小、最早、最晚价格，这就是月K线图！！！
  keyby = .(year = year(date), month = month(date))] #按月分组
head(monthly)
```

```{r, eval=FALSE}
# 此段代码不运行

oldpar <- par(mfrow = c(1, 2))
market_data[, { # 可以把 j 当成一个大的匿名函数 
  plot(price ~ date, type = "l",
    main = sprintf("Market data (%d)", year))
}, by = .(year = year(date))] # 按年分组，画两幅图
par(oldpar)
```

```{r}
data("diamonds", package = "ggplot2")
setDT(diamonds)
# 分组做回归
diamonds[, {
  m <- lm(log(price) ~ carat + depth)
  as.list(coef(m))
}, keyby = .(cut)]
```

```{r}
# 定义了一个函数 average，针对不同的列可以分别计算平均值
average <- function(column) {
  market_data[, .(average = mean(.SD[[column]])),
    by = .(year = year(date))]
}
average('price')
average('volume')
```

```{r}
price_cols <- paste0("price", 1:3)
market_data[, (price_cols) := # 添加了三列
              lapply(1:3, function(i) round(price + rnorm(.N, 0, 5), 2))]
head(market_data)

cols <- colnames(market_data)
price_cols <- cols[grep("^price", cols)] # 从所有列中筛选以price开头的列
price_cols

# 更新以price开头的列
market_data[, (price_cols) := lapply(.SD, zoo::na.locf),
  .SDcols = price_cols] # 由于.SDcols的限制，.SD 中的列仅限于 price_cols
head(market_data)
```
