blogdown:::preview_site()
blogdown:::preview_site()
stop("a")
stop("stop now")
## global options
knitr::opts_chunk$set(
fig.width = 7, fig.asp = 0.618,
out.width = "90%", fig.align = "center",
fig.path = 'Figures/', fig.show = "hold",
warn = 1, warning = FALSE, message = FALSE,
echo = TRUE, comment = '#', collapse = F,
cache = T, cache.comments = F,
autodep = TRUE
)
## use necessary packages
library('pacman')
p_load(
# data processing
tidyverse, lubridate, data.table,
# visualization
ggthemes, showtext, gridExtra,
# 可交互表格 DT::datatable()
DT,
# I/O
sqldf,
# web crawler
XML, rvest, httr, reticulate
)
## database engine
options(sqldf.driver = "SQLite")
## plotting
# 包含图的代码块需要fig.showtext = TRUE选项
showtext_auto(enable = TRUE)
# ggplot2图形需要在主题中显式指定中文字体才能正常显示图中的中文
windowsFonts(YaHei = windowsFont("Microsoft YaHei"))
# pdf中图形内部的中文字体设置
pdf.options(family = "GB1")
## 自定义图形主题
# common template
mytheme <- theme_economist_white() +
theme(
text = element_text(family = 'YaHei'),
plot.title = element_text(face = 'bold', size = 14),
plot.subtitle = element_text(size = 12),
plot.caption = element_text(
hjust = 0,
size = 10,
margin = margin(2, 0, 0, 0, 'pt')
),
plot.margin = margin(12, 10, 12, 0, 'pt'),
legend.position = 'top',
legend.justification = 'left',
legend.margin = margin(4, 0, 0, 0, 'pt'),
legend.key.size = unit(1, 'lines'),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10, margin = margin(0, 0, 0, 0, 'pt')),
axis.text = element_text(size = 10, margin = margin(2, 0, 2, 0, 'pt')),
axis.ticks.length = unit(-4, 'pt')
)
# histogram template
theme_bar <- theme_economist_white() +
theme(
text = element_text(family = 'YaHei'),
plot.title = element_text(face = 'bold', size = 14),
plot.subtitle = element_text(size = 12),
plot.caption = element_text(
hjust = 0,
size = 10,
margin = margin(0, 0, 0, 0, 'pt')
),
plot.margin = margin(12, 0, 12, 10, 'pt'),
legend.position = 'top',
legend.justification = 'left',
legend.margin = margin(4, 0, 0, 0, 'pt'),
legend.key.size = unit(0.7, 'lines'),
legend.title = element_blank(),
legend.text = element_text(size = 10, margin = margin(0, 8, 0, 4, 'pt')),
axis.text = element_text(size = 10),
axis.ticks.length = unit(0, 'pt') # 不要坐标轴须
)
system.time(rnorm(10000000))
test0 <- function(x, y) {
if (x > 0)
x
else
y
}
system.time(rnorm(10000000))
system.time(test0(1, rnorm(10000000)))
# 创建一个新环境
e1 <- new.env()
# 创建一个新环境
e1 <- new.env()
# 创建一个新环境
e1 <- new.env()
e1
# 创建一个新环境
e1 <- new.env()
e1 # 环境通常用十六进制数表示，即内存地址
e1$x <- 1
e1[["x"]]
# 创建一个新环境
e1 <- new.env()
e1 # 环境通常用十六进制数表示，即内存地址
e1$x <- 1
e1[["x"]]
exists("x", e1)
get("x", e1)
ls(e1)
# 创建一个新环境
e1 <- new.env()
e1 # 环境通常用十六进制数表示，即内存地址
e1$x <- 1
e1$y <- letters[1:4]
e1[["x"]]
exists("x", e1)
get("x", e1)
ls(e1)
# 创建一个新环境
e1 <- new.env()
e1 # 环境通常用十六进制数表示，即内存地址
e1$x <- 1
e1$y <- letters[1:4]
e1[["y"]]
exists("x", e1)
get("x", e1)
ls(e1)
# 创建一个新环境
e1 <- new.env()
e1 # 环境通常用十六进制数表示，即内存地址
e1$x <- 1
e1$y <- letters[1:4]
e1[["y"]]
exists("x", e1)
get("y", e1)
ls(e1)
# 创建一个新环境
e1 <- new.env()
e1 # 环境通常用十六进制数表示，即内存地址
e1$x <- 1
e1$y <- letters[1:4]
e1[["x"]]
exists("x", e1)
get("y", e1)
ls(e1)
# 创建一个新环境
e1 <- new.env()
e1 # 环境通常用十六进制数表示，即内存地址
e1$x <- 1:5
e1$y <- letters[1:4]
e1[["x"]]
exists("x", e1)
get("y", e1)
ls(e1)
# 创建一个新环境
e1 <- new.env()
e1 # 环境通常用十六进制数表示，即内存地址
e1$x <- 1:5
e1$y <- letters[1:4]
e1[["x"]]
e1$z
exists("x", e1)
get("y", e1)
ls(e1)
addn <- function(y) {
function(x) {
return(x + y)
}
}
add1 <- addn(1)
add2 <- addn(2)
add1(1:10)
add2(1:10)
add1 <- addn(1)
add2 <- addn(2)
add1
add2
add1(1:10)
add2(1:10)
addn <- function(y) {
function(x) {
return(x + y)
}
}
addn
add1 <- addn(1)
add2 <- addn(2)
add1
add2
add1(1:10)
add2(1:10)
add1 <- addn(1)
add2 <- addn(2)
add1
environment(add1)$y
# add1的输出结果除了函数表达式，还包含了环境
# 这表明add1不在当前环境（全局环境）中
add2
environment(add2)$y
add1(1:10)
add2(1:10)
color_line <- function(col){
function(...){
plot(..., type = "l", lty = 1, col = col)
}
}
color_line <- function(col){
function(...){
plot(..., type = "l", lty = 1, col = col)
}
}
red_line <- color_line("red")
red_line(rnorm(30), main = "Red line plot")
# 极大似然估计
# 传递数据，返回包含待估参数的闭包
nloglik <- function(x){
n <- length(x)
function(mean, sd){
log(2*pi)*n/2+n*log(sd)+sum((x-mean)^2)/(2*sd^2)
}
}
# 极大似然估计
# 传递数据，返回包含待估参数的闭包
nloglik <- function(x){
n <- length(x)
function(mean, sd){
log(2*pi)*n/2+n*log(sd)+sum((x-mean)^2)/(2*sd^2)
}
}
data <- rnorm(10000, 1, 2)
stats4::mle(nloglik(data), start = list(mean = 0, sd = 1), method = "L-BFGS-B", lower = c(-5, 0.01), upper = c(5, 10))
# 极大似然估计
# 传递数据，返回包含待估参数的闭包
nloglik <- function(x){
n <- length(x)
function(mean, sd){
log(2*pi)*n/2+n*log(sd)+sum((x-mean)^2)/(2*sd^2)
}
}
data <- rnorm(10000, 1, 2)
fit <- stats4::mle(nloglik(data), start = list(mean = 0, sd = 1), method = "L-BFGS-B", lower = c(-5, 0.01), upper = c(5, 10))
fit$coef
# 极大似然估计
# 传递数据，返回包含待估参数的闭包
nloglik <- function(x){
n <- length(x)
function(mean, sd){
log(2*pi)*n/2+n*log(sd)+sum((x-mean)^2)/(2*sd^2)
}
}
data <- rnorm(10000, 1, 2)
fit <- stats4::mle(nloglik(data), start = list(mean = 0, sd = 1), method = "L-BFGS-B", lower = c(-5, 0.01), upper = c(5, 10))
fit@coef
# 极大似然估计
# 传递数据，返回包含待估参数的闭包
nloglik <- function(x){
n <- length(x)
function(mean, sd){
log(2*pi)*n/2+n*log(sd)+sum((x-mean)^2)/(2*sd^2)
}
}
data <- rnorm(10000, 1, 2)
fit <- stats4::mle(nloglik(data), start = list(mean = 0, sd = 1), method = "L-BFGS-B", lower = c(-5, 0.01), upper = c(5, 10))
fit@coef
hist(data, freq = F, ylim = c(0, 0.25))
add <- function(x, y, z){x+y+z}
product <- function(x, y, x){x*y*z}
add <- function(x, y, z){x+y+z}
product <- function(x, y, z){x*y*z}
combine <- function(f, x, y, z){
f(x, y, z)
}
add <- function(x, y, z) {
x + y + z
}
product <- function(x, y, z) {
x * y * z
}
combine <- function(f, x, y, z) {
f(x, y, z)
}
combine(add, 3,4,5)
combine(product, 3,4,5)
lapply(1:3, `+`， 3)
lapply(1:3, `+`， 3)
lapply(1:3, `+`, 3)
lapply(1:3, add, 3)
lapply(1:3, add, 3)
lapply(1:3, `+`, 3)
lapply(1:3, add(), 3)
lapply(1:3, `+`, 3)
lapply(1:3, addn(3))
